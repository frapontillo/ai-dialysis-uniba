\documentclass[preprint]{acm_proc_article-sp}
\usepackage[italian]{babel}
\usepackage[shortcuts]{extdash}
\usepackage[utf8]{inputenc}
\usepackage{bigfoot}
\pagenumbering{arabic}

\begin{document}

\title{Previsione di Sintomatologie Post-Dialisi}
\subtitle{Studio e realizzazione di un sistema supervisionato di estrazione regole}

\numberofauthors{1}
\author{
	\alignauthor
	Francesco Pontillo\\
       \affaddr{Universit\'a degli Studi di Bari}\\
       \affaddr{Dipartimento di Informatica}\\
       \affaddr{Via E. Orabona, 4 - 70125  Bari, Italy}\\
       \email{francescopontillo@gmail.com}
}

\maketitle

\begin{abstract}
Implementazione Prolog dell'algoritmo di Intelligenza Artificiale C4.5, con k-fold test e confronto con altri sistemi pre-esistenti di classificazione.
\end{abstract}

\section{Obiettivo}
Obiettivo del processo di Data Mining del sistema da sviluppare \'e di prevedere possibili sintomatologie successive ad una seduta di emodialisi.
A partire da specifici dati registrati durante una dialisi, si vuole prevedere quali classi di sintomatologie il paziente potr\'a riscontrare dal momento in cui la dialisi termina al momento in cui esegue la seduta di dialisi successiva.

In questo modo, il medico pu\'o confermare la possibilit\'a di occorrenza di una o pi\'u problematiche suggerite, ed eventualmente prescrivere una opportuna terapia per contrastare la sua insorgenza.

\section{Selezione degli attributi}
I dati a disposizione nella base di dati da analizzare sono numerosi, e devono essere selezionati appropriatamente per evitare l'introduzione di attributi poco rilevanti con lo scopo del sistema.

Ogni seduta di dialisi memorizza (1) una \textbf{data} di svolgimento, (2) la \textbf{durata} della seduta stessa, (3) un identificativo del \textbf{paziente}, (4) altri \textbf{parametri} registrati durante la sessione e (5) eventuali \textbf{sintomatologie} riscontrate.

\subsection{Dati del paziente}
Le informazioni relative ai pazienti sono ricavate, anonimizzandole, dalla base di dati originale. Ai fini del processo di estrazione delle regole, \'e opportuno considerare il \textbf{sesso} del paziente e la sua \textbf{et\'a} al momento della seduta di dialisi in analisi\footnote{Ci\'o non esclude la possibilit\'a di considerare altri dati relativi al paziente; l'algoritmo da realizzare potrebbe essere esteso andando a considerare anche i dati relativi alle malattie pregresse del paziente ed eventuali comorbidit\'a registrate.}.

\subsection{Parametri della seduta di dialisi}
I parametri pi\'u rilevanti di una seduta di dialisi, al fine di prevedere eventuali sintomatologie successive, sono divisi in pi\'u categorie \cite{bellazziintelligent}  \cite{pmid15749092}.

A. L'\textbf{efficienza della rimozione dei prodotti di scarto} \'e indotta dai valori dei parametri riportati in Tabella \ref{table:parametri-1}.

\begin{table}[h]
\centering
\begin{tabular}{|c|l|} \hline
$KT/V$ & indice di efficienza dialitica\\ \hline
$QB$ & flusso di sangue trattato\\ \hline
$WS$ & peso iniziale \\ \hline
$WE$ & peso finale \\ \hline
$PWE$ & peso finale ottimale \\ \hline
$PT$ & durata ottimale \\ \hline
$T$ & durata reale \\
\hline\end{tabular}
\caption{Parametri di efficienza eliminazione scarti}
\label{table:parametri-1}
\end{table}

B. L'efficienza dell'eliminazione dell'acqua all'interno del corpo del paziente \'e indotta dai parametri in Tabella \ref{table:parametri-2}.

\begin{table}[h]
\centering
\begin{tabular}{|c|l|} \hline
$SPS$ & pressione sistolica iniziale \\ \hline
$SPE$ & pressione sistolica finale \\ \hline
$DPS$ & pressione diastolica iniziale\\ \hline
$DPE$ & pressione diastolica finale\\ \hline
$BV$ & volume ematico finale\\
\hline\end{tabular}
\caption{Parametri di efficienza eliminazione acqua}
\label{table:parametri-2}
\end{table}

C. Altre tipologie di dati che potrebbero risultare utili a fornire previsioni significative sono riportati in Tabella \ref{table:parametri-3}.

\begin{table}[h]
\centering
\begin{tabular}{|c|l|} \hline
$PBF$ & flusso sangue teorico\\ \hline
$BF$ & flusso sangue reale\\ \hline
$PUF$ & ultrafiltrazione media teorica\\ \hline
$UF$ & ultrafiltrazione media reale\\
\hline\end{tabular}
\caption{Altri parametri di efficienza dialitica}
\label{table:parametri-3}
\end{table}

\subsection{Attributi derivati}\label{attributi-derivati}
A partire dalle informazioni disponibili nella base di dati, risulta evidente la presenza di alcuni attributi ``nascosti'' che possono essere più utili ai fini dell'apprendimento.

In tabella \ref{table:parametri-derivati} sono elencati gli attributi derivati dalle precedenti tabelle; ad esempio, $\Delta WL$ rappresenta la differenza fra la perdita di peso programmata e quella effettiva, a sua volta calcolata come differenza fra peso iniziale e peso finale.

\begin{table}[h]
\centering
\begin{tabular}{|c|l|} \hline
$PWL$ & perdita peso programmata\\ \hline
$RWL$ & perdita peso reale\\ \hline
$\Delta WL$ & differenza perdita peso\\ \hline
$\Delta T$ & differenza durata trattamento\\ \hline
$SPA$ & pressione sistolica media \\ \hline
$DPA$ & pressione diastolica media \\ \hline
$\Delta BF$ & differenza flusso sangue \\ \hline
$\Delta UF$ & differenza UF medio \\
\hline\end{tabular}
\caption{Parametri derivati}
\label{table:parametri-derivati}
\end{table}

\subsection{Sintomatologie}
Il sistema verr\'a addestrato con istanze di esempio pre\-/classificate. La classificazione consiste nell'assegnazione, ad ogni esempio, di una o pi\'u categorie di sintomi, ad esempio: aritmia sintomatica, aritmia asintomatica, astenia, brividi, brividi e dispnea, cefalea, collasso (PA < 30\% inizio), conati di vomito, crampi, depressione, ansia, diarrea, dispnea e molti altri.

Inoltre, \'e prevista la classe `asintomatico', che definisce una sintomatologia assente corrispondente ad un esempio negativo dal punto di vista della classificazione.

\section{Selezione dei dati}
Le informazioni sottoposte all'algoritmo di apprendimento sono state selezionate a partire da una base dati molto ricca\footnote{Circa dal 1999 ai primi mesi del 2014.} e sono stati sottoposti ad una serie di passaggi\footnote{Tutte le trasformazioni e selezioni di dati descritte in questa sezione sono codificate nel \texttt{scripts/01-sql-server-tables.sql}.}.

\subsection{Creazione dei valori derivati}
Per poter istanziare i valori degli attributi definiti in \ref{attributi-derivati}, \'e stata eseguita una query di tipo \texttt{SELECT} che preleva informazioni dalla tabella di origine ed effettua semplici calcoli di trasformazione.

In questo modo, alla fine del processo di trasformazione, gli attributi per ogni seduta di dialisi sono:

\begin{itemize}
\item \verb|SESSION_ID|, l'ID della seduta di dialisi, utile per identificare la seduta in ogni momento
\item \verb|SESSION_DATE|, la data di esecuzione
\item \verb|KTV|, il valore di KT/V
\item \verb|QB|, il valore di QB
\item \verb|PROG_WEIGHT_LOSS|, la perdita peso programmata
\item \verb|REAL_WEIGHT_LOSS|, la perdita peso reale
\item \verb|DELTA_WEIGHT|, la differenza fra la perdita di peso reale e quella programmata
\item \verb|PROG_DURATION|, la durata programmata della dialisi
\item \verb|REAL_DURATION|, la durata effettiva della dialisi
\item \verb|DELTA_DURATION|, la differenza fra la durata reale e quella programmata
\item \verb|SAP_START|, la pressione sistolica arteriosa prima della seduta
\item \verb|SAP_END|, la pressione sistolica arteriosa dopo la seduta
\item \verb|AVG_SAP|, la pressione sistolica arteriosa media
\item \verb|DAP_START|, la pressione diastolica arteriosa prima della seduta
\item \verb|DAP_END|, la pressione diastolica arteriosa dopo la seduta
\item \verb|AVG_DAP|, la pressione diastolica arteriosa media
\item \verb|BLOOD_VOLUME|, il volume di sangue trattato
\item \verb|DELTA_BLOOD_FLOW|, la differenza fra flusso di sangue teorico ed effettivo
\item \verb|DELTA_UF|, la differenza dell'ultrafiltrazione media reale e teorica
\end{itemize}

Come si nota, sono stati eliminati alcuni attributi originali: il flusso di sangue teorico e reale e l'ultrafiltrazione media teorica e reale.

\subsection{Associazione con sintomatologie}
\label{associazione-sintomi}
Nel programma che genera i dati, le sintomatologie vengono comunicate e quindi inserite, dal medico o dall'infermiere, qualche momento prima della dialisi successiva del paziente. 
Per poter mettere a confronto i dati della seduta di dialisi, di cui sopra, con i dati della sintomatologia rilevata, \'e stato necessario eseguire una query molto complessa per mettere in correlazione:
\begin{itemize}
\item il paziente
\item la data di dialisi
\item la data di dialisi minore fra quelle successive alla data di riferimento della seduta originaria
\end{itemize}

\subsection{Associazione con dati del paziente}
Infine, il dato della sintomatologia singola è stato associato univocamente con il paziente di riferimento, tramite l'apposito identificativo.

Tutte queste operazioni sono state eseguite staticamente, ovvero andando a creare una copia dei record in altre tabelle; ci\'o si \'e reso necessario in quanto, anche utilizzando macchine potenti, la selezione completa dei record impiegava interi minuti per completare, soprattutto a causa dell'associazione poco ottimizzata con le date (cfr. \ref{associazione-sintomi}).

\subsection{Migrazione dei dati}
Per una gestione pi\'u libera dei dati, si \'e scelto di migrare le tabelle create da Microsoft SQL Server a MySQL\footnote{Lo script di migrazione \'e presente in \texttt{scripts/02-mysql-migration-script.sql} e viene richiamato in automatico, tramite appositi parametri di connessione, dal file batch \texttt{03-mysql-copy-migrated-tables.cmd}.}, anche in ottica futura (cfr. \ref{sviluppi-futuri}).

\section{Pulizia dei dati}
\label{pulizia-dati}
Una volta spostati i dati su un database MySQL, si \'e scelto di eliminare alcuni record e mantenerne altri pi\'u rilevanti\footnote{Gli script rilevanti sono contenuti nel file \texttt{scripts/04-mysql-scores.sql}.}. La base dati originaria, infatti, contiene $185476$ record.

\subsection{Calcolo dello score}
Ad ogni riga di rilevazione sintomo \'e stato associato un punteggio, o \textit{score}, che permetta di capire quanto quella riga \'e completa (e quindi pi\'u o meno rilevante rispetto alle altre).

Fissato il numero degli attributi (di dialisi) a $15$, un record con \textit{score} pi\'u elevato sar\'a selezionato con pi\'u probabilit\'a per avviare il processo di apprendimento.

\subsection{Pazienti rilevanti}
Inoltre, lo \textit{score} \'e stato utilizzato anche per poter eliminare, dai record gi\'a selezionati, tutti quelli che appartengono a pazienti che hanno meno di $5$ rilevazioni di sintomi con uno \textit{score} percentuale pi\'u basso dell'$80\%$.

Tutti i dati selezionati fino a questo punto, quindi, appartengono a pazienti che hanno almeno $5$ rilevazioni di sintomi ottimali.

\subsection{Gestione dei valori nulli}
I valori nulli sono stati gestiti ``staticamente'', ovvero per ogni paziente sono state calcolate le medie dei valori di ogni attributo (ignorando quindi i valori nulli); in un passo successivo, sono stati scansionati tutti i record e, qualora fosse rilevato un valore nullo, \'e stato inserito il valore medio relativo al paziente associato.

Tutto ci\'o, tuttavia, ha portato comunque a mantenere alcuni valori nulli all'interno della base dati. Ad esempio, poche rilevazioni di sintomatologia contengono valori effettivi di \verb|KTV|, probabilmente perch\'e si tratta di una misura di difficile calcolo da parte dei medici.

Alcuni record, inoltre, non contenevano l'ID del sintomo target rilevato, e si \'e pertanto assunto che l'utente avesse erroneamente cancellato (dall'interfaccia del sistema) la dicitura ``asintomatico'', aggiungendo comunque una sintomatologia nulla (con ID uguale a $1$).

\section{Apprendimento di regole in Prolog}
\label{prolog}
Per apprendere regole utili a classificare appositamente una seduta di dialisi si \'e scelto di implementare il funzionamento base dell'algoritmo C4.5 di Ross Quinlan \cite{Quinlan:1993:CPM:583200} \cite{Salzberg:1994:BRC:198277.637825}, in modo tale da:
\begin{itemize}
\item utilizzare la sintomatologia come attributo target (da classificare)
\item poter sfruttare i numerosi dati disponibili
\item generare un albero di decisione
\item convertire l'albero in un insieme di regole Prolog
\end{itemize}

Il programma Prolog \'e diviso in $6$ moduli, ognuno dei quali si occupa di parti differenti del programma\footnote{Ogni regola definita nei diversi moduli \'e stata documentata. La documentazione \'e consultabile aprendo in un browser il file \texttt{doc/index.html}. Per un problema nel modulo di generazione della documentazione, i link diretti dalla \texttt{index.html} alle regole documentate non funzionano; utilizzare, invece, i collegamenti ai moduli, dai quali si pu\'o comunque accedere alla documentazione delle regole.}.

Si \'e scelto di utilizzare SWI-Prolog\cite{SWI:2014:Online} come ambiente Prolog.

\subsection{Utility}
\label{prolog-utility}
Sono stati realizzati $2$ moduli che realizzano funzioni di utilit\'a.

\subsubsection{\texttt{util.pl}}
\verb|util.pl| contiene brevi regole che implementano:
\begin{itemize}
\item timer, con avvio, lettura e stop (\verb|timer_start|, \verb|timer_get|, \verb|timer_stop|, tra gli altri)
\item formattazione di millisecondi (\verb|format_ms|) e secondi (\verb|format_s|) nel formato intellegibile \texttt{\{M\}m \{S\}s \{MS\}ms}
\item stampa a video di generiche liste di elementi o di un elemento singolo, con ritorno a capo (\verb|println|)
\item generici \textit{helper} per liste, che realizzano funzioni di minimo e massimo (\verb|list_min|, \verb|list_max|), ricerca dell'elemento pi\'u comune (\verb|list_most_common|) e dell'indice di un elemento specifico (\verb|index_of|), oltre che funzionalit\'a di aggiunta e rimozione di elementi
\item concatenazione di elementi di una lista in una stringa
\item realizzazione del logaritmo in base $2$ (\verb|log2|), utilizzato successivamente (cfr. \ref{prolog-learner}).
\end{itemize}

\subsection{Avvio del programma}
\label{prolog-main}
Il programma principale \'e definito nel modulo \verb|main.pl|, che si occupa del caricamento in memoria di tutti i file Prolog necessari e di definire il metodo \verb|main(Config, Symptom)|:
\begin{itemize}
\item \verb|Config| dichiara al programma qual \'e il file di configurazione con il quale si vuole accedere al database.\footnote{Alcuni file di configurazione di esempio sono presenti nella cartella \texttt{prolog/config}}. Vedi \ref{prolog-database} per il l'accesso al database. Si \'e optato per un file di configurazione che contenesse tutti i parametri di connessione poich\'e la scrittura degli stessi ad ogni avvio del programma sarebbe risultata troppo verbosa.
\item \verb|Symptom| definisce l'ID del sintomo che si vuole utilizzare come esempio positivo per l'attributo target.
\end{itemize}

%TODO controllare sintomo default

Entrambi i parametri supportano i meta-valori \verb|default| e \verb|ask|: \verb|default| esegue un \textit{fallback} dei parametri sul file di configurazione \texttt{prolog/config/database.properties} e sul sintomo con ID $2$, mentre \verb|ask| imposta il programma in modo da chiedere all'utente, in maniera interattiva e quando necessario, gli stessi parametri.

Sono anche presenti funzioni di avvio rapido: \verb|main_def/0| (che avvia il programma con parametri di default), \verb|main/0| (che avvia in modalit\'a \verb|ask|) e \verb|make_doc/0| (che genera la documentazione HTML).

Per uscire dal programma e chiudere in maniera pulita la connessione, basta chiamare la regola \verb|out|.

\subsection{Lettura dal database}
\label{prolog-database}
Una volta letti i parametri impostati dal \verb|main| vengono eseguiti i processi di connessione e lettura dei dati utili alla generazione dell'albero di decisione.

La lettura dal database \'e possibile grazie alla libreria \verb|odbc| di SWI-Prolog \footnote{Per questa ragione, \'e necessario che sulla macchina client siano installati i driver di connessione ODBC al database target. Poich\'e i parametri sono impostati dal programma Prolog, non \'e necessario creare nessuna connessione sulla macchina.}.

\subsubsection{Connessione}
La connessione al database avviene tramite la regola \verb|connect| (nelle varianti) e i parametri nel file di configurazione impostato in precedenza: driver ODBC, indirizzo e porta, username, password e database. Se si \'e in modalit\'a \verb|ask|, il file di configurazione verr\'a chiesto all'utente, e nel caso in cui non esista viene eseguito un \textit{fallback} sul file di default.

La lettura del file \verb|.properties| \'e eseguita da
\begin{verbatim}
  read_database_params(Path, Driver, Server, 
  	Port, Database, User, Password)
\end{verbatim}
che utilizza il costrutto \verb|open_table| di SWI-Prolog per leggere i campi del file di propriet\'a e unificare con le variabili passate in input.

\subsubsection{Lettura sintomi}
Il passo successivo consiste nella lettura di tutte le possibili sintomatologie che potrebbero verificarsi nel corso di una seduta di dialisi. La regola \verb|get_symptoms/0| esegue una semplice \texttt{SELECT} sulla base di dati, ottenendo, salvando in memoria e stampando a video i sintomi.

\subsubsection{Lettura degli esempi}
La regola \verb|update_records/0| si occupa di ottenere e salvare in memoria tutti gli esempi che devono essere utilizzati per avviare il processo di apprendimento.

Poich\'e \'e necessaria la selezione sia degli esempi positivi che di quelli negativi, \verb|update_records/0| esegue lo stesso \textit{statement} di \texttt{SELECT}, opportunamente creato e preparato, andando a modificare l'ID della sintomatologia target da ottenere\footnote{La regola \verb|get_records/2| prepara lo statement all'esecuzione.}.

Il salvataggio dei record avviene andando ad asserire, nella memoria del programma Prolog, strutture del tipo:
\begin{verbatim}
  positive(ID, Attribute, Value)
  negative(ID, Attribute, Value)
\end{verbatim}
In questo modo \'e sempre possibile accedere a qualsiasi coppia attributo-valore di un esempio con uno specifico ID, sia esso positivo o negativo.

\'E stata realizzata anche la regola
\begin{verbatim}
  example(Type, ID, Attribute, Value)
\end{verbatim}
dove \verb|Type| pu\'o essere \verb|positive| o \verb|negative|. Tramite questa modalit\'a \'e possibile accedere a tutti gli esempi prelevati dalla base di dati. Sono presenti, inoltre, regole di conteggio e di verifica di esistenza (cfr. documentazione HTML).

\subsection{Suddivisione attributi in range}
\label{prolog-categories}
Gli attributi dei dati di esempio possono essere numerici (a virgola mobile) o categorici, ma in ogni caso sono identificati da un numero. Essi sono stati dichiarati esplicitamente tramite la clausola \verb|data_type(Attribute, Type)|, che definisce quindi la tipologia per ogni attributo.

Per ogni attributo, quindi, si \'e avviato un processo di suddivisione in pi\'u \textit{range}:
\begin{itemize}
\item gli attributi di tipo \verb|category| 
\end{itemize}

\subsection{Apprendimento e test}
\label{prolog-learner}

\section{Sviluppi futuri}
\label{sviluppi-futuri}

\begin{itemize}
\item Migliore gestione dei valori nulli (a runtime, tramite misura dell'information gain)
\item Gestione multi-classe dell'albero di decisione
\item Aggregazione dati ottimi da pi\'u database italiani e non (quando disponibili)
\end{itemize}

% The following two commands are all you need in the
% initial runs of your .tex file to
% produce the bibliography for the citations in your paper.
\bibliographystyle{abbrv} % standard abbrv style
\bibliography{bibliography}  % substitute the name of 'your' Bibliography here
% You must have a proper ".bib" file
% and remember to run:
% latex bibtex latex latex (in that particular order) in order to resolve all the 'numerical values'
% be they for figures, equation numbers, references, footnotes, etc. etc.
%
\balancecolumns

% That's all folks! % GM Sept. 2008
\end{document}
